# nimo智能眼镜 PLM+ERP 技术架构选型文档 v2.0

> 文档版本：2.0
> 更新日期：2026-02-05
> 编写：OpenClaw AI
> 变更：统一采用 Go 语言技术栈

---

## 一、技术选型总览

### 1.1 选型原则

| 原则 | 说明 |
|-----|------|
| **小团队友好** | 20人团队，单一技术栈降低学习和维护成本 |
| **统一技术栈** | 全栈Go，简化招聘、培训、运维 |
| **快速迭代** | 编译型语言，部署简单，性能稳定 |
| **飞书优先** | 深度集成飞书生态，复用飞书基础能力 |
| **云原生** | 容器化部署，支持弹性扩缩容 |
| **成本可控** | 优先开源方案，避免商业授权费用 |

### 1.2 技术栈全景图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              客户端层                                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │   Web端     │  │  飞书小程序  │  │  移动H5    │  │  飞书工作台  │    │
│  │ React 18   │  │  原生组件    │  │ 响应式     │  │  应用嵌入   │    │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              网关层                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                       APISIX Gateway                             │   │
│  │  • 统一入口          • 限流熔断          • JWT认证               │   │
│  │  • 路由转发          • 日志采集          • 灰度发布              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    ▼                               ▼
┌─────────────────────────────────┐ ┌─────────────────────────────────────┐
│          PLM 服务群              │ │            ERP 服务群                │
│         (Go + Gin)              │ │           (Go + Gin)                │
├─────────────────────────────────┤ ├─────────────────────────────────────┤
│ • product-service    (8002)     │ │ • supplier-service      (8101)      │
│ • bom-service        (8003)     │ │ • procurement-service   (8102)      │
│ • project-service    (8004)     │ │ • inventory-service     (8103)      │
│ • document-service   (8005)     │ │ • manufacturing-service (8104)      │
│ • ecn-service        (8006)     │ │ • sales-service         (8105)      │
│ • test-service       (8007)     │ │ • aftersales-service    (8106)      │
│                                 │ │ • finance-service       (8107)      │
└─────────────────────────────────┘ └─────────────────────────────────────┘
                    │                               │
                    └───────────────┬───────────────┘
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                            共享服务层                                    │
│                           (Go + Gin)                                    │
├─────────────────────────────────────────────────────────────────────────┤
│  • user-service (8001)        用户认证、RBAC权限                        │
│  • integration-service (8010) 飞书集成（SSO、审批、通知、任务）          │
│  • file-service (8011)        文件上传下载、MinIO管理                    │
│  • notification-service (8012) 消息通知（飞书、邮件、站内信）            │
│  • report-service (8013)      报表生成、数据导出                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              数据层                                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌────────────┐  │
│  │ PostgreSQL   │  │    Redis     │  │   MinIO      │  │ RabbitMQ   │  │
│  │  16.x        │  │    7.x       │  │  对象存储    │  │  3.13      │  │
│  │              │  │              │  │              │  │            │  │
│  │ • 主数据库   │  │ • JWT缓存   │  │ • 设计图纸   │  │ • 异步任务 │  │
│  │ • JSONB扩展  │  │ • 热点数据   │  │ • BOM附件    │  │ • 事件驱动 │  │
│  │ • 递归CTE    │  │ • 分布式锁   │  │ • 报告文档   │  │ • 系统集成 │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  └────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                            基础设施层                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌────────────┐  │
│  │ Kubernetes   │  │ GitLab CI/CD │  │ Prometheus   │  │   Loki     │  │
│  │  容器编排    │  │  持续交付    │  │  + Grafana   │  │  日志聚合  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  └────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.3 为什么选择纯Go技术栈

| 维度 | Go单一栈 | Go+Python双栈 |
|-----|---------|--------------|
| **运维复杂度** | ⭐ 简单 | ⭐⭐⭐ 复杂 |
| **招聘成本** | ⭐ 只招Go | ⭐⭐⭐ 两种都要 |
| **代码共享** | ⭐ 无障碍 | ⭐⭐⭐ 需要适配 |
| **部署镜像** | ⭐ 统一基础镜像 | ⭐⭐ 多种基础镜像 |
| **调试排查** | ⭐ 统一工具链 | ⭐⭐⭐ 多套工具 |
| **开发效率** | ⭐⭐ 略啰嗦 | ⭐ Python更快 |
| **团队一致性** | ⭐ 统一规范 | ⭐⭐⭐ 各写各的 |

**结论**：对于20人小团队，单一技术栈的**运维和管理优势**远大于开发效率的微小差异。

---

## 二、前端技术栈

### 2.1 核心框架

| 技术 | 版本 | 用途 |
|-----|------|------|
| **React** | 18.2.x | UI框架 |
| **TypeScript** | 5.3.x | 类型安全 |
| **Ant Design** | 5.12.x | UI组件库 |
| **Vite** | 5.0.x | 构建工具 |
| **pnpm** | 8.x | 包管理 |
| **Turborepo** | 1.x | Monorepo管理 |

### 2.2 状态管理

| 技术 | 用途 |
|-----|------|
| **Zustand** | 全局状态（用户信息、权限、主题） |
| **TanStack Query** | 服务端状态（API数据缓存、同步） |

### 2.3 专业组件

| 组件 | 用途 | 说明 |
|-----|------|------|
| **DHTMLX Gantt** | 甘特图 | 项目任务管理 |
| **AG Grid** | 高性能表格 | BOM清单、库存列表 |
| **react-flow** | 流程图 | BOM关系图、审批流程 |
| **ECharts** | 图表 | 数据看板 |
| **TinyMCE** | 富文本 | 文档编辑 |

### 2.4 项目结构

```
frontend/
├── apps/
│   ├── plm/                    # PLM前端
│   │   ├── src/
│   │   │   ├── pages/          # 页面
│   │   │   ├── components/     # 业务组件
│   │   │   ├── hooks/          # 自定义Hooks
│   │   │   ├── stores/         # Zustand stores
│   │   │   ├── services/       # API调用
│   │   │   ├── types/          # 类型定义
│   │   │   └── utils/          # 工具函数
│   │   ├── index.html
│   │   └── vite.config.ts
│   │
│   ├── erp/                    # ERP前端
│   │   └── (同plm结构)
│   │
│   └── portal/                 # 统一门户
│       └── (同plm结构)
│
├── packages/
│   ├── ui/                     # 共享UI组件
│   ├── hooks/                  # 共享Hooks
│   ├── api-client/             # API客户端(自动生成)
│   └── types/                  # 共享类型
│
├── package.json
├── pnpm-workspace.yaml
├── turbo.json
└── tsconfig.base.json
```

---

## 三、后端技术栈（Go统一）

### 3.1 核心框架

| 技术 | 版本 | 用途 |
|-----|------|------|
| **Go** | 1.22.x | 编程语言 |
| **Gin** | 1.9.x | Web框架 |
| **GORM** | 1.25.x | ORM框架 |
| **Wire** | 0.5.x | 依赖注入 |
| **Viper** | 1.18.x | 配置管理 |
| **Zap** | 1.26.x | 结构化日志 |
| **Validator** | 10.x | 参数校验 |

### 3.2 数据访问

| 技术 | 用途 |
|-----|------|
| **GORM** | PostgreSQL ORM |
| **go-redis/redis** | Redis客户端 |
| **minio-go** | MinIO客户端 |
| **amqp091-go** | RabbitMQ客户端 |

### 3.3 工具库

| 库 | 用途 |
|-----|------|
| **golang-jwt/jwt** | JWT处理 |
| **oapi-codegen** | OpenAPI代码生成 |
| **swaggo/swag** | Swagger文档生成 |
| **excelize** | Excel读写 |
| **go-pdf** | PDF生成 |
| **lark-sdk-go** | 飞书官方SDK |

### 3.4 服务标准目录结构

```
service-name/
├── cmd/
│   └── server/
│       └── main.go             # 程序入口
│
├── internal/                   # 私有代码
│   ├── config/
│   │   └── config.go           # 配置定义
│   │
│   ├── handler/                # HTTP处理器
│   │   ├── handler.go
│   │   ├── product.go
│   │   └── middleware.go
│   │
│   ├── service/                # 业务逻辑
│   │   ├── service.go
│   │   └── product_service.go
│   │
│   ├── repository/             # 数据访问
│   │   ├── repository.go
│   │   └── product_repo.go
│   │
│   ├── model/                  # 数据模型
│   │   ├── entity/             # 数据库实体
│   │   ├── dto/                # 传输对象
│   │   └── vo/                 # 视图对象
│   │
│   └── pkg/                    # 服务内部公共包
│       ├── errors/
│       └── utils/
│
├── pkg/                        # 可导出的公共包
│   └── client/                 # 给其他服务调用的客户端
│
├── api/
│   └── openapi.yaml            # OpenAPI定义
│
├── configs/
│   ├── config.yaml             # 默认配置
│   ├── config.dev.yaml
│   └── config.prod.yaml
│
├── migrations/                 # 数据库迁移
│   ├── 000001_init.up.sql
│   └── 000001_init.down.sql
│
├── scripts/                    # 脚本
│   └── generate.sh
│
├── Dockerfile
├── Makefile
├── go.mod
└── go.sum
```

### 3.5 代码示例

**main.go:**
```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "product-service/internal/config"
    "product-service/internal/handler"
    "product-service/internal/repository"
    "product-service/internal/service"
)

func main() {
    // 加载配置
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // 初始化依赖
    db := initDB(cfg.Database)
    redis := initRedis(cfg.Redis)
    
    // 依赖注入
    repo := repository.NewProductRepository(db)
    svc := service.NewProductService(repo, redis)
    h := handler.NewProductHandler(svc)

    // 路由
    r := gin.New()
    r.Use(gin.Recovery())
    r.Use(handler.LoggerMiddleware())
    r.Use(handler.AuthMiddleware(cfg.JWT))
    
    api := r.Group("/api/v1")
    {
        products := api.Group("/products")
        {
            products.GET("", h.List)
            products.GET("/:id", h.Get)
            products.POST("", h.Create)
            products.PUT("/:id", h.Update)
            products.DELETE("/:id", h.Delete)
        }
    }

    // 健康检查
    r.GET("/health/live", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
    r.GET("/health/ready", func(c *gin.Context) {
        // 检查数据库连接等
        c.JSON(200, gin.H{"status": "ok"})
    })

    // 优雅关闭
    srv := &http.Server{
        Addr:    cfg.Server.Addr,
        Handler: r,
    }

    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Failed to start server: %v", err)
        }
    }()

    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    log.Println("Shutting down server...")

    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }

    log.Println("Server exited")
}
```

**handler示例:**
```go
package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    "product-service/internal/model/dto"
    "product-service/internal/service"
)

type ProductHandler struct {
    svc *service.ProductService
}

func NewProductHandler(svc *service.ProductService) *ProductHandler {
    return &ProductHandler{svc: svc}
}

// List godoc
// @Summary 获取产品列表
// @Tags products
// @Accept json
// @Produce json
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(20)
// @Success 200 {object} dto.ProductListResponse
// @Router /products [get]
func (h *ProductHandler) List(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))

    result, err := h.svc.List(c.Request.Context(), page, pageSize)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, result)
}

// Create godoc
// @Summary 创建产品
// @Tags products
// @Accept json
// @Produce json
// @Param body body dto.CreateProductRequest true "产品信息"
// @Success 201 {object} dto.ProductResponse
// @Router /products [post]
func (h *ProductHandler) Create(c *gin.Context) {
    var req dto.CreateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // 获取当前用户
    userID := c.GetString("user_id")
    
    result, err := h.svc.Create(c.Request.Context(), userID, &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, result)
}
```

**service示例:**
```go
package service

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v9"
    "product-service/internal/model/dto"
    "product-service/internal/model/entity"
    "product-service/internal/repository"
)

type ProductService struct {
    repo  *repository.ProductRepository
    redis *redis.Client
}

func NewProductService(repo *repository.ProductRepository, redis *redis.Client) *ProductService {
    return &ProductService{repo: repo, redis: redis}
}

func (s *ProductService) Create(ctx context.Context, userID string, req *dto.CreateProductRequest) (*dto.ProductResponse, error) {
    // 生成产品编码
    code, err := s.generateProductCode(ctx, req.Category)
    if err != nil {
        return nil, fmt.Errorf("generate product code: %w", err)
    }

    product := &entity.Product{
        Code:        code,
        Name:        req.Name,
        Category:    req.Category,
        Status:      entity.ProductStatusDraft,
        CreatedBy:   userID,
        CreatedAt:   time.Now(),
    }

    if err := s.repo.Create(ctx, product); err != nil {
        return nil, fmt.Errorf("create product: %w", err)
    }

    // 清除列表缓存
    s.redis.Del(ctx, "products:list:*")

    return dto.NewProductResponse(product), nil
}

func (s *ProductService) List(ctx context.Context, page, pageSize int) (*dto.ProductListResponse, error) {
    // 尝试从缓存获取
    cacheKey := fmt.Sprintf("products:list:%d:%d", page, pageSize)
    // ... 缓存逻辑

    products, total, err := s.repo.List(ctx, page, pageSize)
    if err != nil {
        return nil, fmt.Errorf("list products: %w", err)
    }

    return &dto.ProductListResponse{
        Items:    dto.NewProductResponses(products),
        Total:    total,
        Page:     page,
        PageSize: pageSize,
    }, nil
}
```

---

## 四、数据库设计

### 4.1 数据库选型

| 数据库 | 版本 | 用途 |
|-------|------|------|
| **PostgreSQL** | 16.x | 主数据库 |
| **Redis** | 7.2.x | 缓存/会话/分布式锁 |

### 4.2 为什么选PostgreSQL

| 特性 | PostgreSQL | MySQL |
|-----|------------|-------|
| JSON支持 | ⭐⭐⭐⭐⭐ JSONB | ⭐⭐⭐ JSON |
| 递归查询 | ⭐⭐⭐⭐⭐ CTE | ⭐⭐⭐ 8.0+ |
| 窗口函数 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 全文搜索 | ⭐⭐⭐⭐ 内置 | ⭐⭐ 需插件 |
| 扩展性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

**关键场景支持：**
- BOM递归展开 → 递归CTE
- 产品灵活属性 → JSONB
- 库存批次追溯 → 窗口函数

### 4.3 数据库分库

```
PostgreSQL Instance
├── nimo_user       # 用户权限库
│   ├── users
│   ├── roles
│   ├── permissions
│   └── user_roles
│
├── nimo_plm        # PLM业务库
│   ├── products
│   ├── bom_headers
│   ├── bom_items
│   ├── projects
│   ├── tasks
│   ├── documents
│   └── ecn_*
│
├── nimo_erp        # ERP业务库
│   ├── suppliers
│   ├── purchase_*
│   ├── inventory_*
│   ├── production_*
│   ├── sales_*
│   └── finance_*
│
└── nimo_log        # 日志库
    ├── audit_logs
    ├── operation_logs
    └── api_logs
```

### 4.4 Redis Key规范

| 用途 | Key格式 | TTL |
|-----|--------|-----|
| JWT Token | `token:{jti}` | 与JWT同步 |
| 用户会话 | `session:{user_id}` | 24h |
| 数据缓存 | `cache:{service}:{entity}:{id}` | 5m-1h |
| 列表缓存 | `cache:{service}:{entity}:list:{hash}` | 5m |
| 分布式锁 | `lock:{resource}:{id}` | 30s |
| 幂等性 | `idempotent:{key}` | 24h |
| 限流 | `ratelimit:{api}:{user}` | 1m |

---

## 五、服务通信

### 5.1 通信方式

| 场景 | 协议 | 说明 |
|-----|------|------|
| 前端→后端 | HTTP REST | OpenAPI 3.0规范 |
| 服务→服务(同步) | HTTP REST | 内网调用 |
| 服务→服务(异步) | RabbitMQ | 事件驱动 |

### 5.2 为什么不用gRPC

| 维度 | HTTP REST | gRPC |
|-----|-----------|------|
| 学习成本 | ⭐ 低 | ⭐⭐⭐ 高 |
| 调试难度 | ⭐ curl直接调 | ⭐⭐⭐ 需工具 |
| 文档生成 | ⭐ Swagger | ⭐⭐ 需额外工具 |
| 性能 | ⭐⭐ 够用 | ⭐ 更快 |
| 团队熟悉度 | ⭐ 都会 | ⭐⭐⭐ 需培训 |

**结论**：对于内部服务调用，HTTP REST性能足够，开发调试更简单。

### 5.3 服务调用示例

```go
// pkg/client/user_client.go
package client

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type UserClient struct {
    baseURL    string
    httpClient *http.Client
}

func NewUserClient(baseURL string) *UserClient {
    return &UserClient{
        baseURL: baseURL,
        httpClient: &http.Client{
            Timeout: 5 * time.Second,
        },
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    url := fmt.Sprintf("%s/api/v1/users/%s", c.baseURL, userID)
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    // 传递trace header
    if traceID := ctx.Value("trace_id"); traceID != nil {
        req.Header.Set("X-Trace-ID", traceID.(string))
    }
    
    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("user service returned %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

### 5.4 RabbitMQ事件设计

**Exchange定义：**
```
nimo.events (topic exchange)
├── plm.product.created
├── plm.product.updated
├── plm.bom.released
├── plm.project.status_changed
├── plm.ecn.approved
├── erp.order.created
├── erp.inventory.low_stock
└── erp.shipment.completed
```

**事件消息格式：**
```json
{
  "event_id": "evt_20260205_abc123",
  "event_type": "plm.bom.released",
  "timestamp": "2026-02-05T21:16:00+08:00",
  "source": "bom-service",
  "data": {
    "bom_id": "BOM-2026-001",
    "product_id": "PRD-NIMO-001",
    "version": "1.0"
  },
  "metadata": {
    "trace_id": "trace_xxx",
    "user_id": "u_123"
  }
}
```

---

## 六、API网关

### 6.1 APISIX配置

**路由配置：**
```yaml
routes:
  # 用户服务
  - uri: /api/v1/auth/*
    upstream:
      nodes:
        "user-service:8001": 1
    plugins:
      limit-req:
        rate: 20
        burst: 10
        key: remote_addr

  # PLM服务
  - uri: /api/v1/plm/*
    upstream:
      type: roundrobin
      nodes:
        "plm-product-service:8002": 1
        "plm-bom-service:8003": 1
        "plm-project-service:8004": 1
    plugins:
      jwt-auth: {}
      limit-req:
        rate: 100
        burst: 50
        key: consumer_name

  # ERP服务
  - uri: /api/v1/erp/*
    upstream:
      type: roundrobin
      nodes:
        "erp-supplier-service:8101": 1
        "erp-procurement-service:8102": 1
        "erp-inventory-service:8103": 1
    plugins:
      jwt-auth: {}
```

### 6.2 JWT认证流程

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           JWT认证流程                                     │
└──────────────────────────────────────────────────────────────────────────┘

  用户          前端           网关          user-service        飞书
   │            │             │                │                 │
   │ 1.点击登录  │             │                │                 │
   │ ─────────>│             │                │                 │
   │            │ 2.重定向飞书 │                │                 │
   │ <──────────────────────────────────────────────────────────>│
   │            │             │                │                 │
   │ 3.授权回调  │             │                │                 │
   │ ─────────>│ 4. /auth/callback             │                 │
   │            │ ────────────>────────────────>│                 │
   │            │             │                │ 5.换token       │
   │            │             │                │ ───────────────>│
   │            │             │                │ <───────────────│
   │            │             │                │ 6.获取用户信息   │
   │            │             │                │ ───────────────>│
   │            │             │                │ <───────────────│
   │            │             │<───────────────│ 7.生成JWT       │
   │            │ <────────────               │                 │
   │ <──────────│ 8.返回JWT    │                │                 │
   │ 9.存localStorage          │                │                 │
   │            │             │                │                 │
   │ 10.请求API │             │                │                 │
   │ ─────────>│ Authorization: Bearer xxx     │                 │
   │            │ ────────────>│                │                 │
   │            │             │ 11.验证JWT     │                 │
   │            │             │ 解析用户信息    │                 │
   │            │             │ ──────────────>│                 │
   │            │             │ <──────────────│                 │
   │ <──────────────────────────               │                 │
```

---

## 七、容器与部署

### 7.1 Dockerfile (Go服务统一模板)

```dockerfile
# ===== Build Stage =====
FROM golang:1.22-alpine AS builder

# 安装依赖
RUN apk add --no-cache git ca-certificates tzdata

WORKDIR /app

# 下载依赖（利用缓存）
COPY go.mod go.sum ./
RUN go mod download

# 复制源码
COPY . .

# 编译
ARG SERVICE_NAME
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -ldflags="-w -s" -o /app/server ./cmd/server

# ===== Runtime Stage =====
FROM alpine:3.19

RUN apk --no-cache add ca-certificates tzdata

WORKDIR /app

# 复制二进制和配置
COPY --from=builder /app/server .
COPY --from=builder /app/configs ./configs

# 时区
ENV TZ=Asia/Shanghai

# 非root用户运行
RUN adduser -D -u 1000 appuser
USER appuser

EXPOSE 8000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8000/health/live || exit 1

CMD ["./server"]
```

### 7.2 docker-compose (开发环境)

```yaml
version: '3.8'

services:
  # ===== 基础设施 =====
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: nimo
      POSTGRES_PASSWORD: nimo123
      POSTGRES_MULTIPLE_DATABASES: nimo_user,nimo_plm,nimo_erp,nimo_log
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-multi-db.sh:/docker-entrypoint-initdb.d/init-multi-db.sh
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U nimo"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

  rabbitmq:
    image: rabbitmq:3.13-management-alpine
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: nimo
      RABBITMQ_DEFAULT_PASS: nimo123
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

  minio:
    image: minio/minio
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin123
    volumes:
      - minio_data:/data

  # ===== 共享服务 =====
  user-service:
    build:
      context: ./services/user-service
      dockerfile: Dockerfile
    ports:
      - "8001:8001"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started

  # ===== PLM服务 =====
  plm-product-service:
    build:
      context: ./services/plm/product-service
    ports:
      - "8002:8002"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
    depends_on:
      - postgres
      - redis
      - rabbitmq

  # ... 其他服务类似

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
  minio_data:
```

### 7.3 Kubernetes部署

**Deployment示例：**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: plm-product-service
  namespace: nimo
  labels:
    app: plm-product-service
    tier: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: plm-product-service
  template:
    metadata:
      labels:
        app: plm-product-service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8002"
        prometheus.io/path: "/metrics"
    spec:
      containers:
        - name: product-service
          image: registry.example.com/nimo/plm-product-service:v1.0.0
          ports:
            - containerPort: 8002
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
          livenessProbe:
            httpGet:
              path: /health/live
              port: 8002
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health/ready
              port: 8002
            initialDelaySeconds: 5
            periodSeconds: 5
          envFrom:
            - configMapRef:
                name: plm-config
            - secretRef:
                name: plm-secrets
---
apiVersion: v1
kind: Service
metadata:
  name: plm-product-service
  namespace: nimo
spec:
  selector:
    app: plm-product-service
  ports:
    - port: 8002
      targetPort: 8002
```

### 7.4 环境规划

| 环境 | 用途 | 基础设施 |
|-----|------|---------|
| **local** | 本地开发 | Docker Desktop |
| **dev** | 开发联调 | 单节点服务器 + docker-compose |
| **test** | 测试环境 | K3s单节点 |
| **staging** | 预发布 | 与生产同配置 |
| **prod** | 生产环境 | Kubernetes集群(3节点) |

---

## 八、监控与可观测性

### 8.1 监控栈

| 组件 | 用途 |
|-----|------|
| **Prometheus** | 指标采集 |
| **Grafana** | 指标可视化 |
| **Loki** | 日志聚合 |
| **Jaeger** | 链路追踪 |
| **AlertManager** | 告警管理 |

### 8.2 Go服务指标暴露

```go
// internal/handler/metrics.go
package handler

import (
    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "path", "status"},
    )

    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
        },
        []string{"method", "path"},
    )
)

func init() {
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
}

func MetricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        timer := prometheus.NewTimer(httpRequestDuration.WithLabelValues(c.Request.Method, c.FullPath()))
        
        c.Next()
        
        timer.ObserveDuration()
        httpRequestsTotal.WithLabelValues(c.Request.Method, c.FullPath(), string(rune(c.Writer.Status()))).Inc()
    }
}

func MetricsHandler() gin.HandlerFunc {
    h := promhttp.Handler()
    return func(c *gin.Context) {
        h.ServeHTTP(c.Writer, c.Request)
    }
}
```

### 8.3 告警规则

```yaml
# prometheus/alerts.yaml
groups:
  - name: nimo-alerts
    rules:
      - alert: HighErrorRate
        expr: |
          sum(rate(http_requests_total{status=~"5.."}[5m])) 
          / sum(rate(http_requests_total[5m])) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }}"

      - alert: HighLatency
        expr: |
          histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le)) > 0.5
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "P95 latency is {{ $value }}s"

      - alert: PodNotReady
        expr: kube_pod_status_ready{condition="true"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Pod not ready"
```

---

## 九、安全设计

### 9.1 认证授权

| 层级 | 方案 |
|-----|------|
| 身份认证 | 飞书OAuth 2.0 + JWT |
| 接口授权 | RBAC + 数据权限 |
| 服务间 | 内网信任 + 服务账号 |

### 9.2 JWT Token设计

```go
type Claims struct {
    jwt.RegisteredClaims
    UserID      string   `json:"uid"`
    Name        string   `json:"name"`
    Email       string   `json:"email"`
    FeishuUID   string   `json:"feishu_uid"`
    Roles       []string `json:"roles"`
    Permissions []string `json:"perms"`
}

// Token生成
func GenerateToken(user *User) (string, error) {
    claims := Claims{
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    "nimo-auth",
            Subject:   user.ID,
            Audience:  []string{"nimo-plm", "nimo-erp"},
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            ID:        uuid.New().String(),
        },
        UserID:      user.ID,
        Name:        user.Name,
        Email:       user.Email,
        FeishuUID:   user.FeishuUserID,
        Roles:       user.Roles,
        Permissions: user.Permissions,
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    return token.SignedString(privateKey)
}
```

### 9.3 API安全清单

| 安全项 | 实现 |
|-------|------|
| HTTPS | TLS 1.3，HSTS |
| 认证 | JWT Bearer Token |
| 限流 | 令牌桶，100 req/s/user |
| 输入校验 | validator库 + 自定义规则 |
| SQL注入 | GORM参数化查询 |
| 敏感日志 | 脱敏处理 |
| 审计日志 | 全量操作记录 |

---

## 十、开发规范

### 10.1 Git工作流

```
main ─────────────────────────────────────────────────> (生产)
  │
  └── release/v1.0 ──────────────────────────────────> (发布分支)
        │
        └── develop ─────────────────────────────────> (开发主线)
              │
              ├── feature/PLM-001-product-crud ─────> (功能分支)
              ├── feature/ERP-002-supplier-api
              └── bugfix/PLM-003-bom-calc-error
```

### 10.2 提交规范

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type：**
- `feat`: 新功能
- `fix`: 修复
- `docs`: 文档
- `refactor`: 重构
- `test`: 测试
- `chore`: 构建/工具

**示例：**
```
feat(plm-bom): 实现BOM多级展开API

- 支持递归查询最多10层
- 添加Redis缓存
- 新增展开层级参数

Closes PLM-123
```

### 10.3 代码规范

```go
// 1. 错误处理：包装错误，保留上下文
if err != nil {
    return fmt.Errorf("create product: %w", err)
}

// 2. 命名：清晰直观
type ProductService struct{}     // 好
type PrdSvc struct{}             // 差

// 3. 注释：解释为什么，不是什么
// 使用乐观锁防止并发更新冲突
func (s *Service) UpdateWithVersion(...)

// 4. 函数：单一职责，不超过50行
func (s *Service) CreateProduct(...) error {
    // 参数校验
    // 业务逻辑
    // 数据持久化
    // 返回结果
}
```

### 10.4 Makefile模板

```makefile
.PHONY: all build test lint run docker

SERVICE_NAME := product-service
VERSION := $(shell git describe --tags --always --dirty)

all: lint test build

build:
	go build -ldflags="-X main.Version=$(VERSION)" -o bin/$(SERVICE_NAME) ./cmd/server

test:
	go test -v -race -coverprofile=coverage.out ./...

lint:
	golangci-lint run ./...

run:
	go run ./cmd/server

docker:
	docker build -t $(SERVICE_NAME):$(VERSION) .

migrate-up:
	migrate -path migrations -database "$(DATABASE_URL)" up

migrate-down:
	migrate -path migrations -database "$(DATABASE_URL)" down 1

swagger:
	swag init -g cmd/server/main.go -o api/docs

mock:
	mockery --all --output internal/mocks
```

---

## 十一、技术版本清单

| 类别 | 技术 | 版本 |
|-----|------|------|
| **前端** | React | 18.2.x |
| | TypeScript | 5.3.x |
| | Ant Design | 5.12.x |
| | Vite | 5.0.x |
| | pnpm | 8.x |
| **后端** | Go | 1.22.x |
| | Gin | 1.9.x |
| | GORM | 1.25.x |
| | Wire | 0.5.x |
| **数据库** | PostgreSQL | 16.x |
| | Redis | 7.2.x |
| | RabbitMQ | 3.13.x |
| **存储** | MinIO | RELEASE.2024-01 |
| **网关** | APISIX | 3.8.x |
| **容器** | Docker | 24.x |
| | Kubernetes | 1.29.x |
| **监控** | Prometheus | 2.48.x |
| | Grafana | 10.2.x |
| | Loki | 2.9.x |
| **CI/CD** | GitLab CI | 16.x |

---

## 附录：ADR决策记录

### ADR-001: 统一使用Go语言

**状态：** 已采纳（替代v1.0的Go+Python方案）

**背景：** v1.0计划PLM用Go、ERP用Python，但评估后认为复杂度过高。

**决策：** 全部服务统一使用Go 1.22 + Gin

**理由：**
1. 20人小团队，单一技术栈降低管理成本
2. Go性能足够，开发效率可通过代码生成弥补
3. 统一部署流程、监控方案、招聘标准

**后果：**
- 正面：运维简单，团队统一，代码共享方便
- 负面：复杂业务逻辑代码量略多（可接受）

---

### ADR-002: 服务间通信用HTTP REST而非gRPC

**状态：** 已采纳

**背景：** gRPC性能更好，但团队不熟悉。

**决策：** 服务间同步调用使用HTTP REST

**理由：**
1. 团队都熟悉HTTP，无学习成本
2. curl/Postman可直接调试
3. 当前规模性能差异可忽略
4. 异步场景用RabbitMQ已解耦

**后果：**
- 正面：开发调试效率高
- 负面：性能略低于gRPC（可接受）

---

*文档结束*
